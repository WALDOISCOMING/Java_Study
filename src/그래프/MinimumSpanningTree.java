package 그래프;
/*
 * 생성일: 2017-07-21
 * 생성자: 길경완
 * 수정일: x
 * 수정자: x
 * 제목 :최소 신장 트리
 * 내용 :
 *입력은 b개의 도시를 연결하는 비용을 넣어준다. 여기에서 최소의 비용으로 모든 도시가 서로 연결되도록 해주는것이다.
 *양의 가중치를 가지는 무방향 그래프에서 사용한다는 가정이다. 이러한 과정에서 해가 유일하지는 않을수도있다.
 *최소비용신장 트리라고 부르는 이유는 해답이 트리가 되기 때문이다. 사이클이 생기면 안되며, n개의 노드에 n-1개의 링크가 존재한다.
 *네트워크 디자인문제에 대하여 쓸만한 방법론.
 *아래 2개는 최소비용신장트리의 가장 대표적 해결법들. 아래 2개는 모두 공통적 방법론이 잇다.
 *MST의 부분집합 A에 대하여 (내가 골라둔 트리)A∪{(u,v)}->(이유는 MST의 해는 유일하지 않기 때문에 이렇게 표현한다).
 *도 어떠한 MST의 집합이 되는 경우. edge(u,v)는 A에 대하여 안전하다고 한다.->잘 찾아가고 있는 것이다.
 *1.처음에는 A=null
 *2.집합 A에 대하여 안전한 edge를 찾은 후 A에 더한다.
 *3.edge의 갯수가 n-1개가 될 때까지 2를 반복한다.
 *
 *그래프에서 정점들을 두개의 집합 S와 V-S 두개로 나눈것을 컷 (S,V-S)라고 부른다. 여집합의 개념.
 *edge (u,v)에 대하여 u∈S이고 v∈V-S이면->엣지를 연결한다면, edge(u,v)는 cut을 cross한다.
 *edge 부분집합 A에 속한 어떤 edge도 컷 (S,V-S)를 cross하지 않을때->cut이 연결되있지 않는다.
 *이것을 (S,V-S)는 A를 respect한다고 말한다.
 *
 *
 *Kruskal알고리즘
 *	1.edge들을 가중치의 오름차순으로 정렬한다.
 *	2.edge들을 그순서대로 하나씩 선택한다. 단 이미 선택된 edge들과 사이클 형성하지 않도록 한다.
 *	3.n-1 edge 선택되면 종료한다.
 *	A를 지금까지 선택한 edge의 집합이고 A를 포함하는 전체인 MST가 있다고 한다. 이 과정에서 사이클을 피하도록한다. 
 * 	두개 트리를 합칠때 두개  집합의 root를 반환해서 한쪽을 자식으로 넣는다. 이 과정 O(트리높이)의 복잡도가 든다. 
 * 	이럴때 tree 노드 카운트를 하여 작은 트리를 자식으로 보내는 것을 하면 시간을 감소가능하다.
 *	모든 노드를 집합으로 표현한다. 
 *Prim 알고리즘
 *출발노드를 포함한 트리를 점점 키워간다. 매 단계에서 이미 트리에 포함된 노드와 아닌 노드를
 *연결하는 edge중 가장 가중치가 작은걸 선택. 여기에서는 사이클에 대한 고민을 생각하지 않아도 된다.
 *
 *내일 크루스컬,프림 만들기.
 */

public class MinimumSpanningTree {

	
	
	class Prim
	{
		
	}
	class Kruskal
	{
		//배열에서 순차적으로 가져온다.
		//오름차순으로 정렬한다.
		public void aa()
		{
			
		}
		
	}
	
	
	
	
	public static void main(String[] args)
	{
		 int[][] graph = {
			      {0, 10, 0, 30, 45, 0}, 
			      {10, 0, 50, 0, 40, 25}, 
			      {0, 50, 0, 0, 35, 15}, 
			      {30, 0, 0, 0, 0, 20}, 
			      {45, 40, 35, 0, 0, 55}, 
			      {0, 25, 15, 20, 55, 0} };


			
	}
}
